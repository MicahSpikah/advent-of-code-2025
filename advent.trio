name: day1a
func
src:
  () => do
    zeros: 0
    cur: 50
    ioReadLines(`io/in.txt`).each step => do
      steps: step[1..-1].parseInt
      if (step[0..0] == "L") steps = steps * -1
      cur = cur + steps + 100000
      cur = cur.remainder(100)
      if (cur == 0) zeros = zeros + 1
    end
    zeros
  end
---
name: day1b
func
src:
  () => do
    zeros: 0
    cur: 50
    ioReadLines(`io/in.txt`).each step => do
      steps: step[1..-1].parseInt
      stepSize: if (step[0..0] == "L") -1 else 1
      steps.times c => do
        cur = cur + stepSize
        if (cur == -1) cur = 99
        if (cur == 100) cur = 0
        if (cur == 0) zeros = zeros + 1
      end
    end
    zeros
  end
---
name: day2a
func
src:
  () => do
    hits: []
    ioReadStr(`io/in.txt`).split(",").each range => do
      start: range.split("-")[0].parseInt
      stop: range.split("-")[1].parseInt
      times(1 + stop - start) i => do
        str: (i + start).toStr
        half: str.size / 2
        if (str.size.remainder(2) == 0 and str[0..(half - 1)] == str[half..-1]) do
          hits = hits.add(i + start)
        end
      end
    end
    hits.fold(sum)
  end
---
name: day2aFast
func
help: "This is theoretically faster, although I need to figure out the 1-2 digit case. The slow day2a func works, so moving on for now"
src:
  () => do
    hits: []
    ioReadStr(`io/in.txt`).split(",").each range => do
      start: range.split("-")[0].parseInt
      stop: range.split("-")[1].parseInt
      halfSize: if (start.toStr.size.remainder(2) == 0) start.toStr.size / 2 else stop.toStr.size / 2
      startFirstHalf: start.toStr[0..(start.toStr.size - halfSize - 1)].parseInt
      stopFirstHalf: stop.toStr[0..(stop.toStr.size - halfSize - 1)].parseInt
      times(1 + stopFirstHalf - startFirstHalf) i => do
        halfStr: toStr(i + startFirstHalf)
        if (halfStr.size == halfSize) do
          potential: parseInt(halfStr + halfStr)
          if (start <= potential and potential <= stop) hits = hits.add(potential)
        end
      end
    end
    hits
  end
---
name: day2b
func
src:
  () => do
    hits: []
    ioReadStr(`io/in.txt`).split(",").each range => do
      start: range.split("-")[0].parseInt
      stop: range.split("-")[1].parseInt
      times(1 + stop - start) i => do
        str: (i + start).toStr
        times(floor(str.size / 2)) substrLen => do
          substrLen = substrLen + 1
          if (str.size.remainder(substrLen) == 0) do
            base: str[0..(substrLen - 1)]
            check: ""
            times(str.size / substrLen) () => check = check + base
            if (check == str) do
              hits = hits.add(str.parseInt)
            end
          end
        end
      end
    end
    hits.unique.fold(sum)
  end
---
name: day3
func
help: "The generic way to solve the problem. Give it as many batteries as you're allowed to turn on"
src:
  (digits) => do
    sum: 0
    ioReadLines(`io/in.txt`).each bank => do
      maxIndex: 0
      ((digits - 1)..0).each outDigit => do
        (maxIndex..(bank.size - outDigit - 1)).each digit => if (bank[digit].toChar > bank[maxIndex].toChar) maxIndex = digit
        sum = sum + bank[maxIndex].toChar.parseInt * 10.pow(outDigit)
        maxIndex = maxIndex + 1
      end
    end
    sum
  end
---
name: day3a
func
src:
  () => do
    sum: 0
    ioReadLines(`io/in.txt`).each bank => do
      maxIndex: 0
      (1..0).each outDigit => do
        (maxIndex..(bank.size - outDigit - 1)).each digit => if (bank[digit].toChar > bank[maxIndex].toChar) maxIndex = digit
        sum = sum + bank[maxIndex].toChar.parseInt * 10.pow(outDigit)
        maxIndex = maxIndex + 1
      end
    end
    sum
  end
---
name: day3b
func
src:
  () => do
    sum: 0
    ioReadLines(`io/in.txt`).each bank => do
      maxIndex: 0
      (11..0).each outDigit => do
        (maxIndex..(bank.size - outDigit - 1)).each digit => if (bank[digit].toChar > bank[maxIndex].toChar) maxIndex = digit
        sum = sum + bank[maxIndex].toChar.parseInt * 10.pow(outDigit)
        maxIndex = maxIndex + 1
      end
    end
    sum
  end
---
name: day4a
func
src:
  () => do
    sum: 0
    lines: ioReadLines(`io/in.txt`)

    (0..(lines.size - 1)).each y => do
      (0..(lines[y].size - 1)).each x => do
        if (lines[y][x].toChar == "@" and lines[(y - 1).max(0)..(y + 1).min(lines.size - 1)].reduce(0) (acc, line) => do
            acc + line[(x - 1).max(0)..(x + 1).min(line.size - 1)].replace(".", "").size
          end <= 4) sum = sum + 1
      end
    end
    sum
  end
---
name: day4b
func
src:
  () => do
    sum: 0
    lines: ioReadLines(`io/in.txt`)

    // Make borders to make my life easier
    lines = lines.insert(0, lines.first.replace("@", "."))
    lines = lines.add(lines.first)
    lines = lines.map line => "." + line + "."

    (0..lines.first.size * lines.size).eachWhile count => do
      sumAtLoopStart: sum
      (1..(lines.size - 2)).each y => do
        (1..(lines[y].size - 2)).each x => do
          if (lines[y][x].toChar == "@" and lines[(y - 1)..(y + 1)].reduce(0) (acc, line) => do
              acc + line[(x - 1)..(x + 1)].replace(".", "").size
            end <= 4) do
            lines = lines.set(y, lines[y][0..(x - 1)] + "." + lines[y][(x + 1)..-1])
            sum = sum + 1
          end
        end
      end
      if (sumAtLoopStart == sum) sum
    end
  end
---
name: day5a
func
src:
  () => do
    countingRanges: true
    fresh: 0
    freshRanges: []
    ioReadLines(`io/in.txt`).each line => do
      if (line.isEmpty) return countingRanges = false
      if (countingRanges) do
        parts: line.split("-")
        freshRanges = freshRanges.add(parts.first.parseNumber..parts.last.parseNumber)
      else if (freshRanges.any range => range.contains(parseNumber(line))) fresh = fresh + 1
    end
    fresh
  end
---
name: day5b
func
src:
  () => do
    fresh: 0
    freshRanges: []
    ioReadLines(`io/in.txt`).each line => do
      parts: line.split("-")
      if (parts.size == 2) freshRanges = freshRanges.add(parts.first.parseNumber..parts.last.parseNumber)
    end
    freshRanges = freshRanges.sort() (a, b) => a.start <=> b.start
    growingRange: freshRanges.first
    freshRanges.each range => do
      if (range.start > growingRange.end) do
        fresh = fresh + 1 + growingRange.end - growingRange.start
        return growingRange = range
      end
      growingRange = growingRange.start..max(growingRange.end, range.end)
    end
    if (growingRange.isNonNull) fresh = fresh + 1 + growingRange.end - growingRange.start
    fresh
  end
---
name: day6a
func
src:
  () => do
    lines: ioReadLines(`io/in.txt`)

    acc: lines[0].split
    lines[1..-2].each line => line
      .split
      .each() (v, index) => acc = acc.set(index, acc[index] + lines[-1].split[index] + v)

    acc.map(eval).fold(sum)
  end
---
name: day6b
func
src:
  () => do
    lines: ioReadLines(`io/in.txt`)

    sum: 0

    accumStr: null
    op: null

    lines[-1].each() (char, index) => do
      char = char.toChar
      num: lines[0..-2].map(line => line[index].toChar).concat.trim
      if (num.isEmpty) do
        evaluated: accumStr.eval
        sum = sum + evaluated
        accumStr = null
        return null
      end
      if (char != " ") op = char
      if (accumStr.isNull) accumStr = num
      else accumStr = accumStr + op + num
    end
    sum + accumStr.eval
  end
---
name: day7a
func
src:
  () => do
    lines: ioReadLines(`io/in.txt`)

    splits: 0
    beams: [lines.first.index("S")]
    lines.each line => do
      beamsMod: []
      beams.each beam => do
        if (line[beam].toChar == "^") do
          beamsMod = beamsMod.add(beam - 1)
          beamsMod = beamsMod.add(beam + 1)
          splits = splits + 1
        else beamsMod = beamsMod.add(beam)
      end
      beams = beamsMod.unique
    end

    splits
  end
---
name: day7b
desc:
  Run in reverse.
  Keep a count for each column. Initialize to 1
  For each row from the bottom up:
    If the column is a splitter, its new count is the sum of the left and right columns of the previous row
    Otherwise the column is the count from the previous row
  Return the count of the column at the S index
func
src:
  () => do
    lines: ioReadLines(`io/in.txt`)

    count: lines[-1].split(".")[1..-1].map x => 1
    ((lines.size - 1)..0).each lineIndex => do
      line: lines[lineIndex]
      count = count.map() (val, index) => do
        if (line[index].toChar == "^") count[index - 1] + count[index + 1]
        else count[index]
      end
      count.echo
    end

    count[lines.first.index("S")]
  end
---
name: day8a
func
src:
  () => do
    dist: (a, b) => (0..2).map(i => (a[i] - b[i]) * (a[i] - b[i])).fold(sum)

    boxes: ioReadLines(`io/in.txt`).map line => line.split(",").map x => x.parseNumber

    // Start by finding all the distances as a list of lists
    // Flatten that down to a single list
    // Sort it to top 1000
    topK: (0..(boxes.size - 2)).map(b1 => do
      ((b1 + 1)..(boxes.size - 1)).map b2 => {b1: b1, b2: b2, bd: boxes[b1].dist(boxes[b2])}
    end).flatten.sort((a, b) => a->bd <=> b->bd)[0..999]

    //topK contains the 1000 closest connections. Now figure out how many circuits I have?
    //Start with everyone on its own circuit
    circuits: (0..999).map x => [x]

    //For each connection, if the two ends are on different circuits, connect them
    topK.each circuit => do
      c1: circuits.eachWhile() (c, i) => if (c.contains(circuit->b1)) i
      c2: circuits.eachWhile() (c, i) => if (c.contains(circuit->b2)) i
      if (c1 != c2) do
        circuits = circuits.set(c1, circuits[c1].addAll(circuits[c2])).remove(c2)
      end
    end

    circuits.map(size)
  end
---
name: day8b
func
src:
  () => do
    dist: (a, b) => (0..2).map(i => (a[i] - b[i]) * (a[i] - b[i])).fold(sum)

    boxes: ioReadLines(`io/in.txt`).map line => line.split(",").map x => x.parseNumber

    // Start by finding all the distances as a list of lists
    // Flatten that down to a single list
    // Sort it
    boxDists: (0..(boxes.size - 2)).map(b1 => do
      ((b1 + 1)..(boxes.size - 1)).map b2 => {b1: b1, b2: b2, bd: boxes[b1].dist(boxes[b2])}
    end).flatten.sort() (a, b) => a->bd <=> b->bd

    //circuits is a list of lists. Each list contains all of the box #s on that circuit
    //Start with everyone on its own circuit
    circuits: (0..999).map x => [x]

    //For each connection, if the two ends are on different circuits, connect them
    boxDists.eachWhile circuit => do
      c1: circuits.eachWhile() (c, i) => if (c.contains(circuit->b1)) i
      c2: circuits.eachWhile() (c, i) => if (c.contains(circuit->b2)) i
      if (c1 != c2) do
        circuits = circuits.set(c1, circuits[c1].addAll(circuits[c2])).remove(c2)
      end
      if (circuits.size == 1) return boxes[circuit->b1].first * boxes[circuit->b2].first
    end
  end
---
name: day9a
func
src:
  () => do
  end